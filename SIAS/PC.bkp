#ESTRUTURAS PRINCIPAIS ---------------------------------------------------------------------

class CPU:
    #ESTRUTURA DA CPU------------------------------------------------------------
    
    #UNIDADE LÓGICA E ARITMÉTICA
    class ULA:
        AC= '00000000 000000000000 00000000 000000000000'   #Acumulador: manter operandos e resultados das operações
        MQ= '00000000 000000000000 00000000 000000000000'   #Multiplicador: manter operandos e resultados das operações
        MBR='00000000 000000000000'     #Registrador de buffer da memória: recebe/envia palavra para memória/Entrada/Saida

        def circuito():
            print('circuito ULA')

    #UNIDADE DE CONTROLE
    class UC:
        IBR='00000000 000000000000'     #Registrador de Buffer da instrução: próxima instrução a ser executada
        PC= '000000000000'              #Contador de programa: endereço do próximo par de instruções
        IR= '00000000'                  #Registrador de instrução: opcode da instrução sendo executada
        MAR='000000000000'              #Registrador de endereço da memória: endereço da memória da palavra a ser escrita/lida no MBR

        #Função do ciclo de instrução
        def ciclo_instrucao():
            
            #Ciclo de instrução
            print('Ciclo de instrução iniciada')
            while(True):
                funcao_UC.busca()       #Ciclo de busca
                funcao_UC.instrucao()   #Ciclo de instrução                
                break

#MEMÓRIA PRINCIPAL
class memoria:
    #             [  Opcode    Endereço  |  Opcode  Endereço    ]
    conteudo=1024*['00000000 000000000000 00000000 000000000000']   #Conteudo       

#ENTRADA/SAÍDA:
class ES:
    memoria.conteudo[0]='00000000 000000000000 00000001 000000001010'

#FUNÇÕES ESPECÌFICAS------------------------------------------------------------

#Funções relacionadas a UC
class funcao_UC:
    #Função para checar se tem instrução a esquerda do conteúdo
    def esquerda(conteudo):
        #conteudo   - Conteúdo que vamos analisar
        
        quebrado=conteudo.split(' ')
        if (quebrado[0]=='00000000'):
            return False
        else:
            return True
        
    #Função para somar o contador
    def contador(atual):
        #atual  - Valor atual do contador
        print('PC=PC+1')

    #Ciclo de busca
    def busca():
        print('\nCICLO DE BUSCA')
        regs('Próxima instrução está no IBR?')
        if(CPU.UC.IBR!='00000000 000000000000'):    #Sim
            CPU.UC.IR=CPU.UC.IBR.split(' ')[0]
            CPU.UC.MAR=CPU.UC.IBR.split(' ')[1]
            regs('Está: \nIR <- IBR (0:7) \nIBR <- MBR(8:19)')

            funcao_UC.contador(CPU.UC.PC)
            regs('PC <- PC+1')
        else:                                       #Não
            CPU.UC.MAR=CPU.UC.PC                    #MAR <- PC
            regs('Não está: MAR <- PC')
            
            CPU.ULA.MBR=func_memoria.M(CPU.UC.MAR)  #MBR <- M(MAR)
            regs('MBR <- M(MAR)\nA instrução à esquerda é requisitada?')

            if(funcao_UC.esquerda(CPU.ULA.MBR)):                      #Sim
                CPU.UC.IBR=CPU.ULA.MBR.split(' ')[2]+' '+CPU.ULA.MBR.split(' ')[3]
                CPU.UC.IR=CPU.ULA.MBR.split(' ')[0]
                CPU.UC.MAR=CPU.ULA.MBR.split(' ')[1]
                regs('É: \nIBR <- MBR (20:39) \nIR <- MBR(0:7)\nMAR <- MBR(8:19)')
            else:                                   #Não                        
                CPU.UC.IR=CPU.ULA.MBR.split(' ')[2]
                CPU.UC.MAR=CPU.ULA.MBR.split(' ')[3]
                regs('Não é: \nIR <- MBR (20:27) \nMAR <- MBR(28:39)')

                funcao_UC.contador(CPU.UC.PC)
                regs('PC <- PC+1')

    #Ciclo de instrução
    def instrucao():
        print('\nCICLO DE EXECUÇÃO')

    
#Funções relacionadas a memória memória
class func_memoria:
    endereco=[]                             #Endereços
    for i in range (1024):
        binario=bin(i).split('0b')[1]       #Convertemos o decimal para binário
        while (len(binario)<12):            #Se é menor que 12                        
                binario='0'+binario         #Adicionamos um 
        endereco.append(binario)            #E retornamos

    #Função para associar o endereço ao conteudo
    def M(end):
        #end    - Endereço do conteúdo que buscamos
        for i in range (1024):
            if (end==func_memoria.endereco[i]):     #Se estamos no endereço correspondente ao argumento
                return memoria.conteudo[i]          #Retornamos o conteudo equivalente
 

#SIMULADOR----------------------------------------------------------------------

#Printar os valores dos registradores e uma mensagem extra
def regs(msg):
    print('\n'+msg)
    print('AC:  '+CPU.ULA.AC)
    print('MQ:  '+CPU.ULA.MQ)
    print('MBR: '+CPU.ULA.MBR)
    print('IBR: '+CPU.UC.IBR)
    print('PC:  '+CPU.UC.PC)
    print('IR:  '+CPU.UC.IR)
    print('MAR: '+CPU.UC.MAR)
    
    
#Iniciamos o PC
def start():
    CPU.UC.ciclo_instrucao()

start()
